# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python3. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python3 tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python3 tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python3 ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o-mini-minio)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-mini-minio-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```bash
venv/bin/python3 ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```bash
venv/bin/python3 ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Always use (activate) it when doing python development. First, to check whether 'uv' is available, use `which uv`. If that's the case, first activate the venv, and then use `uv pip install` to install packages. Otherwise, fall back to `pip`.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o-mini-minio' as the model name for OpenAI's gpt-4o-mini-mini with vision capabilities
- When searching for recent news, use the current year (2025) instead of previous years, or simply use the "recent" keyword to get the latest information
- 对于 React 18 项目，如果不打算进行单元测试，不要安装 @testing-library/react 和相关的测试依赖，因为这些包可能与 React 18 存在兼容性问题
- 如果需要进行测试，建议使用 Vitest 而不是 Jest，因为 Vitest 与 Vite 项目有更好的集成度和兼容性

## 高德地图 MCP 配置规则
- MCP 配置文件位置：/Users/public1/.cursor/mcp.json
- API Key 配置：63e426bd1887061e987988257988573c
- 服务启动命令：npx @amap/amap-maps-mcp-server
- 默认服务端口：3000

## MCP 服务使用规则
- 启动服务前确保 mcp.json 格式正确
- API Key 必须通过环境变量配置
- 服务健康检查：curl http://localhost:3000/health
- 所有请求需要添加错误重试机制
- 注意请求频率限制

## 开发规范
- 使用 TypeScript 进行开发
- 遵循 RESTful API 设计规范
- 实现完整的错误处理机制
- 添加详细的日志记录
- 确保代码注释完整

## 测试规范
- 服务启动前进行配置验证
- 定期检查服务健康状态
- 保存测试结果日志
- 监控 API 调用限制

## 安全规则
- API Key 必须通过环境变量管理
- 敏感配置信息不得硬编码
- 实现请求签名验证
- 数据传输使用 HTTPS

## 性能规则
- 实现请求缓存机制
- 控制并发请求数量
- 优化响应时间
- 监控服务资源使用

## AI 中台组开发规范

### 接口协议规范

1. 物料数据接口
```typescript
interface MaterialData {
  componentName: string;     // 组件名称
  id: string;               // 组件唯一标识
  props: Record<string, any>; // 组件属性
  hidden?: boolean;         // 是否隐藏
  title?: string;          // 组件标题
  isLocked?: boolean;      // 是否锁定
  condition?: boolean;     // 条件
  conditionGroup?: string; // 条件组
  children?: MaterialData[]; // 子组件
  i18n?: Record<string, Record<string, string>>; // 国际化配置
}
```

2. Function Call 接口
```typescript
interface FunctionCall {
  name: string;           // 函数名称
  description: string;    // 函数描述
  parameters: {           // 函数参数
    type: string;        // 参数类型
    properties: Record<string, {
      type: string;      // 属性类型
      description: string; // 属性描述
      required?: boolean; // 是否必须
    }>;
    required: string[];   // 必须的参数列表
  };
}
```

### 数据交互标准

1. 低码平台 -> AI 中台
- 提供物料列表（JSON 格式）
- 提供组件 Schema（JSON 格式）
- 提供页面生成需求（自然语言）

2. AI 中台 -> 低码平台
- 返回符合 Schema 的页面配置
- 返回组件属性建议
- 返回错误信息和修改建议

### 错误处理规范

1. 错误码定义
```typescript
enum ErrorCode {
  INVALID_SCHEMA = 'INVALID_SCHEMA',       // Schema 格式错误
  UNKNOWN_COMPONENT = 'UNKNOWN_COMPONENT', // 未知组件
  INVALID_PROPS = 'INVALID_PROPS',        // 属性错误
  GENERATION_FAILED = 'GENERATION_FAILED', // 生成失败
}
```

2. 错误响应格式
```typescript
interface ErrorResponse {
  code: ErrorCode;
  message: string;
  details?: Record<string, any>;
  suggestions?: string[];
}
```

### 测试规范

1. Schema 验证测试
- 验证生成的 Schema 格式是否正确
- 验证组件名称是否在物料列表中
- 验证必需属性是否完整

2. 功能测试
- 测试不同类型组件的生成
- 测试组件嵌套和属性继承
- 测试国际化配置生成

3. 性能测试
- 响应时间监控
- 内存使用监控
- 并发请求处理

### 协作规范

1. 版本控制
- 使用语义化版本号
- 记录 API 变更历史
- 维护向后兼容性

2. 文档维护
- API 文档实时更新
- 示例代码及时补充
- 错误码说明完善

3. 代码审查
- 遵循代码规范
- 确保测试覆盖
- 性能影响评估

### 使用模型规范

1. DeepSeek
- 模型：deepseek-chat
- 用途：Schema 生成和验证
- 特点：对代码理解深入

2. ChatGPT
- 模型：gpt-4o-mini
- 用途：自然语言理解和转换
- 特点：上下文理解准确

### 开发流程

1. 需求接收
- 解析物料列表
- 理解页面需求
- 确认生成范围

2. Schema 生成
- 组件选择
- 属性配置
- 结构组织

3. 验证优化
- 格式检查
- 完整性验证
- 性能优化

4. 结果返回
- 数据格式化
- 错误处理
- 建议生成

## 低代码平台开发经验

### 类型定义规范
- 统一使用 `PageGenerationRequest` 接口定义请求参数
- 确保所有服务类中的方法参数类型一致
- 使用 TypeScript 的类型推导提高代码质量
- 接口定义文件集中管理在 `src/interfaces` 目录

### 错误处理最佳实践
- 使用统一的错误码枚举 `ErrorCode`
- 实现完整的错误响应接口 `ErrorResponse`
- 在服务层统一处理异常并返回标准格式
- 前端展示友好的错误提示信息

### 开发环境配置
- 前端开发服务端口：5173
- 后端代理服务端口：3002
- DeepSeek API 调用统一通过后端代理
- 环境变量配置集中在 `.env` 文件

### 组件开发规范
- 使用 React 函数式组件
- 采用 Ant Design 组件库
- 实现统一的加载状态管理
- 添加必要的类型注解

### 调试技巧
- 使用 console.log 输出关键信息
- 在前端展示详细的错误信息
- 通过 React Developer Tools 调试组件
- 使用 Network 面板监控 API 请求

### 依赖管理规范
- 使用 `--legacy-peer-deps` 安装与 React 18 不兼容的旧版本包
- 使用 `react-json-view` 代替 `@microlink/react-json-view`
- 在 `package.json` 中明确指定依赖版本
- 定期更新依赖以修复安全漏洞

### Schema 生成规范
- 使用 Few-shot 示例提供明确的 Schema 格式
- 在提示词中包含完整的组件属性示例
- 确保生成的 Schema 包含必要的字段（type、title、components）
- 处理 markdown 代码块标记的移除

### 错误处理规范
- 在前端和后端统一错误响应格式
- 提供详细的错误信息和建议
- 在控制台输出调试信息
- 使用 try-catch 包装异步操作

### 测试用例管理
- 提供多样化的测试场景
- 包含不同类型的页面生成需求
- 测试各种组件组合
- 验证错误处理机制

# Scratchpad

## 工作空间准备

### 环境检查清单：
[X] 1. 目录结构
    - 确认工作目录清洁度 ✓
    - 准备必要的子目录 ✓
    - 设置正确的权限 ✓

[X] 2. 开发环境
    - 检查 Python 虚拟环境 ✓ (Python 3.9.12)
    - 验证必要工具可用性 ✓ (pip 25.0.1)
    - 确认环境变量配置 ✓ (.env 文件存在)

[X] 3. 版本控制
    - 确认 Git 状态 ✓ (当前分支: feature/travel-planner)
    - 检查分支状态 ✓ (干净的工作目录)
    - 准备 .gitignore ✓ (已存在)

[X] 4. 依赖管理
    - 检查包管理工具 ✓ (pip 25.0.1)
    - 更新依赖列表 ✓ (requirements.txt)
    - 验证依赖版本 ✓ (所有依赖已更新)

[X] 5. 配置文件
    - 检查配置文件完整性 ✓ (.env 和 mcp.json 已存在)
    - 验证配置有效性 ✓ (API 密钥已配置)
    - 准备模板文件 ✓ (旅行相关文件已存在)

### 配置文件状态：
- .env 文件：
  - OpenAI API 密钥：已配置
  - Anthropic API 密钥：已配置
  - DeepSeek API 密钥：已配置
  - Google API 密钥：需要配置
  - Azure OpenAI 配置：需要配置
- MCP 配置：
  - 配置文件：~/.cursor/mcp.json
  - API 密钥：63e426bd1887061e987988257988573c
  - 服务命令：npx @amap/amap-maps-mcp-server
  - 服务状态：运行中
- 旅行相关文件：
  - travel_plan.html
  - huizhou_trip.md
  - print_button.css
  - 惠州旅游网站提示词.md

### 工具可用性验证状态：
[X] 高德地图 MCP 服务
    - 服务启动成功 ✓
    - 地理编码测试通过 ✓
    - 逆地理编码测试通过 ✓
[ ] LLM API 服务
    - Anthropic API 待测试
    - DeepSeek API 待测试
    - 其他 API 待配置
[ ] 搜索引擎服务
    - DuckDuckGo 搜索待测试
    - 网页抓取待测试
[ ] 截图验证工具
    - 网页截图待测试
    - LLM 图像分析待测试
[ ] Web 爬虫工具
    - 单页抓取待测试
    - 并发抓取待测试

### 下一步：
1. 测试 LLM API 服务
   - 验证 Anthropic API
   - 测试 DeepSeek API
2. 测试搜索和爬虫工具
   - 验证搜索功能
   - 测试网页抓取
3. 准备开发环境
   - 配置 VS Code
   - 设置调试环境

### 注意事项：
- 保持工作空间整洁
- 记录所有配置变更
- 确保工具链完整性
- 维护清晰的目录结构
- 遵循 Git 工作流规范

## 低代码平台开发进展

### 已完成任务：
[X] 1. 接口定义
    - 统一了请求参数类型 ✓
    - 完善了错误处理机制 ✓
    - 规范了响应格式 ✓

[X] 2. 服务层实现
    - 完成 LowCodeService 核心功能 ✓
    - 实现 Schema 生成逻辑 ✓
    - 添加 Schema 优化功能 ✓

[X] 3. 前端开发
    - 创建 Demo 组件 ✓
    - 实现组件选择功能 ✓
    - 添加结果预览功能 ✓

[X] 4. 开发环境
    - 配置开发服务器 ✓
    - 设置代理服务 ✓
    - 管理环境变量 ✓

### 当前任务：
[ ] 1. 功能测试
    - 测试表单生成
    - 测试列表页面
    - 验证错误处理

[ ] 2. 性能优化
    - 优化响应时间
    - 减少不必要的请求
    - 实现缓存机制

[ ] 3. 文档完善
    - 更新接口文档
    - 添加使用示例
    - 补充错误码说明

### 下一步计划：
1. 进行功能测试
   - 验证不同类型页面生成
   - 测试错误处理机制
   - 收集用户反馈

2. 改进用户体验
   - 优化加载状态展示
   - 完善错误提示信息
   - 增加操作引导

3. 代码优化
   - 提取公共组件
   - 优化类型定义
   - 完善注释文档

### 注意事项：
- 保持代码风格一致
- 及时处理类型错误
- 完善错误处理
- 优化用户体验
- 维护文档更新

# 低代码平台开发规范 v2.0

## 环境配置规范

### 环境变量管理
- 使用 .env 文件管理所有环境变量
- 区分开发和生产环境配置
- 敏感信息（如 API 密钥）必须通过环境变量传递
- 提供 .env.example 作为配置模板

### 服务配置
- 前端服务默认端口：3000
- 后端服务默认端口：3002
- API 基础路径配置在环境变量中
- 超时时间、重试次数等通过配置对象管理

## 接口规范

### 请求格式
```typescript
interface PageGenerationRequest {
  description: string;      // 页面功能描述
  components: string[];     // 可用组件列表
}
```

### 响应格式
```typescript
interface PageGenerationResponse {
  success: boolean;         // 是否成功
  data?: MaterialData;      // 生成的页面 Schema
  error?: {
    code: string;          // 错误码
    message: string;       // 错误信息
    details?: any;         // 错误详情
  };
}
```

## 错误处理规范

### 错误码定义
```typescript
enum ErrorCode {
  INVALID_SCHEMA = 'INVALID_SCHEMA',       // Schema 格式错误
  UNKNOWN_COMPONENT = 'UNKNOWN_COMPONENT', // 未知组件
  INVALID_PROPS = 'INVALID_PROPS',        // 属性错误
  GENERATION_FAILED = 'GENERATION_FAILED', // 生成失败
  INVALID_REQUEST = 'INVALID_REQUEST',    // 请求参数错误
  UNAUTHORIZED = 'UNAUTHORIZED',          // 未授权
  NOT_FOUND = 'NOT_FOUND'                // 资源未找到
}
```

### 错误处理流程
1. 前端错误处理
   - 请求超时处理
   - 重试机制
   - 友好的错误提示
   - 错误日志记录

2. 后端错误处理
   - 统一的错误处理中间件
   - 环境相关的错误详情
   - 请求参数验证
   - 错误日志记录

## 性能监控规范

### 前端监控
- 请求响应时间统计
- 请求成功率统计
- 重试次数统计
- 性能指标收集

### 后端监控
- 请求处理时间监控
- 慢请求告警（>1000ms）
- API 调用统计
- 资源使用监控

## 日志规范

### 日志级别
- DEBUG: 调试信息
- INFO: 正常操作信息
- WARN: 警告信息
- ERROR: 错误信息

### 日志内容
- 时间戳
- 请求 ID
- 操作类型
- 详细信息
- 错误堆栈（仅开发环境）

## 安全规范

### API 安全
- 所有敏感信息通过环境变量管理
- API 密钥不得硬编码
- 生产环境必须使用 HTTPS
- 实现请求频率限制

### 数据安全
- 敏感数据脱敏
- 输入数据验证
- 输出数据过滤
- 错误信息安全处理

## 开发流程规范

### 代码审查清单
- 类型定义完整性
- 错误处理完整性
- 性能影响评估
- 安全漏洞检查

### 测试要求
- 单元测试覆盖
- 接口测试覆盖
- 性能测试覆盖
- 错误处理测试

## 部署规范

### 环境准备
- 验证环境变量配置
- 检查端口占用
- 验证 API 密钥有效性
- 检查依赖完整性

### 部署步骤
1. 环境配置检查
2. 依赖安装
3. 构建前端资源
4. 启动后端服务
5. 验证服务可用性

## 维护规范

### 日常维护
- 定期检查日志
- 监控性能指标
- 更新依赖版本
- 备份配置文件

### 问题处理
- 记录问题详情
- 分析根本原因
- 制定解决方案
- 更新文档说明

## 文档规范

### 文档类型
- API 文档
- 部署文档
- 维护文档
- 故障处理文档

### 文档内容
- 接口说明
- 参数说明
- 示例代码
- 常见问题

## 最佳实践

### 开发建议
- 使用 TypeScript 进行开发
- 实现完整的错误处理
- 添加必要的日志记录
- 进行性能优化

### 调试技巧
- 使用环境变量控制日志级别
- 实现请求跟踪机制
- 添加性能监控点
- 使用开发工具进行调试

### 性能优化
- 实现请求缓存
- 控制并发请求
- 优化响应时间
- 减少不必要的请求

### 代码质量
- 遵循代码规范
- 添加注释说明
- 进行代码审查
- 持续改进

## 代码规范检查计划

### 检查清单：
[X] 1. 环境配置检查
    - .env 文件配置 ✓
    - 服务端口配置 ✓
    - API 配置 ✓

[X] 2. 接口规范检查
    - 请求/响应格式 ✓
    - 类型定义 ✓
    - 错误处理 ✓

[X] 3. 性能监控检查
    - 前端监控实现 ✓
    - 后端监控实现 ✓
    - 日志记录 ✓

[X] 4. 安全规范检查
    - 环境变量使用 ✓
    - 数据验证 ✓
    - 错误处理 ✓
    发现问题：
    - 缺少 HTTPS 配置
    - 缺少 CSRF 保护
    - 缺少 API 认证
    - 缺少输入验证
    解决方案：
    - 添加 HTTPS 配置
    - 添加 CSRF 保护
    - 添加 API 密钥认证
    - 添加请求验证

[ ] 5. 文档更新
    - API 文档
    - 部署文档
    - 维护文档

### 当前进度：
1. 已完成环境配置检查和更新
2. 已完成接口规范检查和更新
3. 已完成性能监控检查和更新
4. 已完成安全规范检查和更新
5. 准备开始文档更新

### 发现的问题：
1. 环境配置：
   - 配置项分类不清晰
   - 缺少性能监控相关配置
   - 缺少安全相关配置
   - 缺少缓存相关配置

2. 接口规范：
   - 接口定义不完整
   - 错误处理机制不统一
   - 缺少性能监控相关接口
   - 缺少缓存配置接口

3. 性能监控：
   - 缺少请求追踪机制
   - 缺少性能数据持久化
   - 缺少监控告警机制
   - 缺少监控面板

4. 安全规范：
   - 缺少 HTTPS 配置
   - 缺少 CSRF 保护
   - 缺少 API 认证
   - 缺少输入验证

### 改进措施：
1. 环境配置：
   - 按功能分类组织配置项
   - 添加配置项说明
   - 补充缺失的配置项
   - 统一配置命名规范

2. 接口规范：
   - 完善接口定义
   - 统一错误处理
   - 添加性能监控接口
   - 添加缓存配置接口

3. 性能监控：
   - 实现请求 ID 追踪
   - 添加性能统计接口
   - 配置监控阈值
   - 实现速率限制

4. 安全规范：
   - 添加 HTTPS 配置
   - 实现 CSRF 保护
   - 添加 API 密钥认证
   - 增强输入验证

### 下一步计划：
1. 更新项目文档
   - 编写 API 文档
   - 完善部署文档
   - 补充维护文档
   - 添加安全说明

## 文档更新进度

### 检查清单：
[X] 1. API 文档
    - 基础信息 ✓
    - 认证说明 ✓
    - 错误处理 ✓
    - 接口列表 ✓
    - 速率限制 ✓
    - 缓存策略 ✓
    - 安全说明 ✓

[X] 2. 部署文档
    - 环境要求 ✓
    - 安装步骤 ✓
    - 部署配置 ✓
    - 监控配置 ✓
    - 安全配置 ✓
    - 备份策略 ✓
    - 故障恢复 ✓
    - 维护计划 ✓

[X] 3. 维护文档
    - 日常维护 ✓
    - 定期维护 ✓
    - 故障处理 ✓
    - 监控指标 ✓
    - 维护工具 ✓

[X] 4. 安全文档
    - 安全配置 ✓
    - 安全防护 ✓
    - 安全监控 ✓
    - 应急响应 ✓
    - 安全基准 ✓

### 文档完成情况：
1. API 文档：已完成
   - 添加了完整的接口说明
   - 包含了认证和错误处理
   - 补充了性能建议

2. 部署文档：已完成
   - 详细的部署步骤
   - 完整的配置说明
   - 故障处理流程

3. 维护文档：已完成
   - 日常维护任务
   - 定期维护计划
   - 监控和工具说明

4. 安全文档：已完成
   - 安全配置指南
   - 防护措施说明
   - 应急响应流程

### 下一步计划：
1. 文档审查
   - 检查文档完整性
   - 验证配置正确性
   - 测试示例代码
   - 更新错误信息

2. 实施准备
   - 准备部署环境
   - 配置监控工具
   - 设置安全措施
   - 测试备份恢复

3. 持续改进
   - 收集用户反馈
   - 优化文档结构
   - 更新最佳实践
   - 完善故障案例

## 新增规则

### 文档管理规范
1. 文档结构
   - 使用 Markdown 格式
   - 保持层级清晰
   - 添加适当示例
   - 包含必要说明

2. 更新流程
   - 定期审查文档
   - 及时更新内容
   - 版本号管理
   - 变更记录

3. 质量要求
   - 内容准确完整
   - 格式规范统一
   - 示例可执行
   - 说明易理解

### 安全规范更新
1. 环境变量
   - 统一使用 .env 文件
   - 区分环境配置
   - 加密敏感信息
   - 定期更新密钥

2. 安全防护
   - 实施 HTTPS
   - 配置 CORS
   - 启用 CSRF
   - 限制请求大小

3. 监控告警
   - 异常检测
   - 日志审计
   - 性能监控
   - 安全事件响应

### 维护规范更新
1. 日常维护
   - 服务监控
   - 日志分析
   - 性能优化
   - 安全检查

2. 应急处理
   - 故障响应
   - 数据恢复
   - 版本回滚
   - 事件报告

3. 性能优化
   - 缓存策略
   - 并发控制
   - 资源限制
   - 监控指标

## 经验总结

### 文档编写经验
1. 结构设计
   - 层次分明
   - 重点突出
   - 逻辑清晰
   - 示例丰富

2. 内容组织
   - 循序渐进
   - 详略得当
   - 重点突出
   - 易于理解

3. 维护更新
   - 定期审查
   - 及时修正
   - 版本控制
   - 反馈改进

### 安全实践经验
1. 配置管理
   - 环境隔离
   - 权限控制
   - 加密保护
   - 安全审计

2. 监控告警
   - 实时监控
   - 异常检测
   - 快速响应
   - 持续改进

3. 应急处理
   - 预案准备
   - 快速响应
   - 根因分析
   - 经验总结

### 维护实践经验
1. 日常运维
   - 监控检查
   - 性能优化
   - 安全加固
   - 问题处理

2. 故障处理
   - 快速定位
   - 及时修复
   - 原因分析
   - 预防措施

3. 持续改进
   - 收集反馈
   - 优化流程
   - 更新文档
   - 培训分享

# 文档审查清单

## 内容审查进度

### API 文档审查
[X] 1. 接口定义完整性
    - 所有接口都有明确的请求/响应格式 ✓
    - 包含了错误处理说明 ✓
    - 提供了示例代码 ✓

[X] 2. 安全相关内容
    - 认证机制说明完整 ✓
    - 包含了安全建议 ✓
    - 说明了速率限制 ✓

### 部署文档审查
[X] 1. 环境配置
    - Node.js 版本要求准确 ✓
    - 包含所有必要的依赖 ✓
    - 环境变量配置完整 ✓

[X] 2. 部署步骤
    - 步骤清晰可执行 ✓
    - 包含错误处理说明 ✓
    - 提供了验证方法 ✓

### 维护文档审查
[X] 1. 维护任务
    - 日常维护项目完整 ✓
    - 定期维护计划合理 ✓
    - 包含所有必要的脚本 ✓

[X] 2. 监控指标
    - 性能指标合理 ✓
    - 可用性指标完整 ✓
    - 安全指标明确 ✓

### 安全文档审查
[X] 1. 安全配置
    - 环境变量管理完整 ✓
    - HTTPS 配置正确 ✓
    - API 安全措施充分 ✓

[X] 2. 安全防护
    - CORS 配置合理 ✓
    - CSRF 防护完整 ✓
    - 数据保护措施充分 ✓

## 代码测试清单

### 配置测试
[ ] 1. 环境变量
    - .env 文件格式
    - 必要变量存在
    - 默认值合理

[ ] 2. Nginx 配置
    - SSL 配置有效
    - 代理设置正确
    - 安全头部完整

### 脚本测试
[ ] 1. 维护脚本
    - 备份脚本
    - 监控脚本
    - 部署脚本

[ ] 2. 安全脚本
    - 加密函数
    - 认证中间件
    - 日志处理

## 文档规范更新

### 格式规范
1. 文件命名
   - 使用大写字母
   - 使用 .md 后缀
   - 名称表意清晰

2. 内容组织
   - 层级不超过四级
   - 每节都有说明
   - 代码有注释

3. 示例规范
   - 提供完整示例
   - 包含注释说明
   - 说明预期结果

### 内容规范
1. 通用要求
   - 使用简洁的语言
   - 避免技术术语
   - 提供必要解释

2. 代码示例
   - 完整可执行
   - 包含错误处理
   - 有输入输出说明

3. 配置说明
   - 说明配置项用途
   - 提供默认值
   - 注明是否必须

### 维护规范
1. 版本控制
   - 记录修改历史
   - 标注修改原因
   - 保留旧版本

2. 审查流程
   - 定期审查内容
   - 验证代码示例
   - 更新过期信息

3. 反馈处理
   - 收集用户反馈
   - 及时更新内容
   - 记录常见问题

## 测试规范更新

### 配置测试
1. 环境变量
   - 测试必要性
   - 测试默认值
   - 测试错误处理

2. 服务配置
   - 测试端口设置
   - 测试超时配置
   - 测试重试机制

### 功能测试
1. API 测试
   - 测试认证机制
   - 测试错误处理
   - 测试性能指标

2. 安全测试
   - 测试 HTTPS 配置
   - 测试访问控制
   - 测试数据保护

### 自动化测试
1. 测试脚本
   - 单元测试
   - 集成测试
   - 性能测试

2. 监控测试
   - 可用性监控
   - 性能监控
   - 安全监控

## 经验总结更新

### 文档维护经验
1. 保持简洁
   - 避免冗长描述
   - 突出重点内容
   - 使用清晰结构

2. 及时更新
   - 定期检查内容
   - 验证代码示例
   - 更新配置说明

3. 用户反馈
   - 收集使用问题
   - 补充常见问题
   - 优化使用说明

### 安全实践更新
1. 配置管理
   - 使用环境变量
   - 加密敏感信息
   - 限制访问权限

2. 监控告警
   - 设置合理阈值
   - 及时处理告警
   - 定期检查日志

3. 应急响应
   - 准备应急预案
   - 定期演练
   - 总结改进

## 目录结构规范

### 根目录结构
```
.
├── src/                # 源代码目录
├── dist/               # 构建输出目录
├── scripts/            # 脚本文件目录
├── docs/               # 文档目录
├── tests/              # 测试文件目录
├── tools/              # 工具脚本目录
├── venv/               # Python 虚拟环境
├── node_modules/       # Node.js 依赖
├── .vscode/           # VS Code 配置
├── .github/           # GitHub 配置
├── images/            # 图片资源目录
├── .env               # 环境变量
├── .env.example       # 环境变量示例
├── package.json       # 项目配置
├── tsconfig.json      # TypeScript 配置
├── vite.config.ts     # Vite 配置
├── README.md          # 项目说明
└── requirements.txt    # Python 依赖

### src 目录结构
src/
├── assets/            # 静态资源
├── components/        # 组件
├── interfaces/        # 类型定义
├── pages/            # 页面
├── services/         # 服务
├── styles/           # 样式
├── utils/            # 工具函数
├── test/             # 单元测试
└── examples/         # 示例代码

### scripts 目录结构
scripts/
├── build/            # 构建脚本
├── deploy/           # 部署脚本
├── test/             # 测试脚本
└── utils/            # 工具脚本

### docs 目录结构
docs/
├── api/              # API 文档
├── deployment/       # 部署文档
├── development/      # 开发文档
└── maintenance/      # 维护文档
```

### 目录命名规范
1. 使用小写字母
2. 使用连字符(-)分隔单词
3. 使用有意义的描述性名称
4. 保持简短但清晰

### 文件命名规范
1. 组件文件：使用 PascalCase（如 `Button.tsx`）
2. 工具文件：使用 camelCase（如 `formatDate.ts`）
3. 样式文件：与组件同名（如 `Button.css`）
4. 测试文件：添加 .test 或 .spec 后缀（如 `Button.test.tsx`）
5. 类型定义文件：使用 .d.ts 后缀（如 `types.d.ts`）

### 文件组织规则
1. 相关文件放在同一目录
2. 组件目录包含组件本身、样式、测试和类型定义
3. 共用组件放在 components 目录
4. 页面级组件放在 pages 目录
5. 工具函数放在 utils 目录

### 导入规则
1. 使用相对路径导入相邻文件
2. 使用别名导入远程文件（配置在 tsconfig.json）
3. 第三方库导入放在最前面
4. 本地模块导入放在第三方库后面
5. 样式文件导入放在最后

## 目录结构检查状态

### 已完成的目录规范化：
[X] 1. 文档目录 (docs/)
    - 创建标准子目录结构 ✓
    - 移动现有文档到对应目录 ✓
    - 整理研究文档 ✓

[X] 2. 示例目录 (src/examples/)
    - 创建旅游示例子目录 ✓
    - 移动相关文件 ✓

[X] 3. 配置目录 (.config/)
    - 创建配置目录 ✓
    - 移动配置文件 ✓
    - 保存 VS Code 示例配置 ✓

### 当前目录结构：
```
.
├── src/                # 源代码目录
│   ├── assets/        # 静态资源
│   ├── components/    # 组件
│   ├── interfaces/    # 类型定义
│   ├── pages/        # 页面
│   ├── services/     # 服务
│   ├── styles/       # 样式
│   ├── utils/        # 工具函数
│   ├── test/         # 单元测试
│   └── examples/     # 示例代码
│       └── travel/   # 旅游示例
├── docs/              # 文档目录
│   ├── api/          # API 文档
│   ├── deployment/   # 部署文档
│   ├── development/  # 开发文档
│   ├── maintenance/  # 维护文档
│   └── research/     # 研究文档
├── scripts/           # 脚本目录
│   ├── build/        # 构建脚本
│   ├── deploy/       # 部署脚本
│   ├── test/         # 测试脚本
│   └── utils/        # 工具脚本
└── .config/           # 配置目录
    ├── vscode-example/  # VS Code 示例配置
    └── windsurfrules   # Windsurf 规则
```

### 待优化项：
[ ] 1. 测试目录结构
    - 整合 src/test 和 tests/
    - 规范化测试文件命名

[ ] 2. 工具目录结构
    - 整合 scripts/utils 和 tools/
    - 明确工具脚本分类

[ ] 3. 文档完善
    - 补充缺失的文档
    - 统一文档格式
    - 更新文档索引

### 注意事项：
1. 保持目录结构清晰
2. 遵循命名规范
3. 及时更新文档
4. 维护目录说明
